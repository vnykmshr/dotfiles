#!/usr/bin/env bash

# Dotfiles management script
# Self-management tool for the dotfiles collection

set -euo pipefail

# Configuration
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
SCRIPT_NAME="$(basename "$0")"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Source utilities if available
if [[ -f "$DOTFILES_DIR/lib/utils.sh" ]]; then
    source "$DOTFILES_DIR/lib/utils.sh"
    source "$DOTFILES_DIR/lib/os-detect.sh"
    source "$DOTFILES_DIR/lib/logging.sh"
    detect_os
fi

# Usage information
usage() {
    cat << EOF
$SCRIPT_NAME - Dotfiles management tool

USAGE:
    $SCRIPT_NAME <command> [options]

COMMANDS:
    install         Install or reinstall dotfiles
    update          Update dotfiles from remote repository
    sync            Pull latest changes and reinstall
    backup          Create backup of current configuration
    restore         Restore from backup
    status          Show git status and system info
    edit            Open dotfiles directory in editor
    test            Run installation tests
    clean           Clean up backups and temporary files
    help            Show this help message

OPTIONS:
    --dry-run       Show what would be done without making changes
    --verbose       Enable verbose output
    --force         Force overwrite existing files

EXAMPLES:
    $SCRIPT_NAME install --dry-run    # Preview installation
    $SCRIPT_NAME sync                  # Update and reinstall
    $SCRIPT_NAME backup                # Create backup
    $SCRIPT_NAME test                  # Run tests

EOF
}

# Logging functions (fallback if not available from lib)
log_info() { printf "${BLUE}ℹ %s${NC}\n" "$*" >&2; }
log_success() { printf "${GREEN}✓ %s${NC}\n" "$*" >&2; }
log_warn() { printf "${YELLOW}⚠ %s${NC}\n" "$*" >&2; }
log_error() { printf "${RED}✗ %s${NC}\n" "$*" >&2; }

# Check if we're in a git repository
check_git_repo() {
    if ! git -C "$DOTFILES_DIR" rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not a git repository: $DOTFILES_DIR"
        exit 1
    fi
}

# Install dotfiles
cmd_install() {
    log_info "Installing dotfiles..."

    if [[ -f "$DOTFILES_DIR/install/setup.sh" ]]; then
        exec "$DOTFILES_DIR/install/setup.sh" "$@"
    else
        log_error "Setup script not found: $DOTFILES_DIR/install/setup.sh"
        exit 1
    fi
}

# Update from remote repository
cmd_update() {
    log_info "Updating dotfiles from remote repository..."
    check_git_repo

    cd "$DOTFILES_DIR"

    # Check if there are uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        log_warn "You have uncommitted changes. Stashing them..."
        git stash push -m "Auto-stash before update $(date)"
    fi

    # Pull latest changes
    git pull origin "$(git branch --show-current)"

    log_success "Dotfiles updated successfully"
    log_info "Run '$SCRIPT_NAME install' to apply changes"
}

# Sync: update and reinstall
cmd_sync() {
    log_info "Syncing dotfiles (update + install)..."

    cmd_update
    cmd_install "$@"
}

# Create backup
cmd_backup() {
    local backup_dir="$HOME/.dotfiles-backup-$(date +%Y%m%d-%H%M%S)"

    log_info "Creating backup at: $backup_dir"
    mkdir -p "$backup_dir"

    # List of common config files to backup
    local configs=(
        ".zshrc"
        ".bashrc"
        ".vimrc"
        ".tmux.conf"
        ".gitconfig"
        ".aliases"
    )

    for config in "${configs[@]}"; do
        local file="$HOME/$config"
        if [[ -f "$file" ]]; then
            cp "$file" "$backup_dir/"
            log_info "Backed up: $config"
        fi
    done

    # Backup config directories
    local config_dirs=(
        ".config/nvim"
        ".config/tmux"
    )

    for dir in "${config_dirs[@]}"; do
        local source_dir="$HOME/$dir"
        if [[ -d "$source_dir" ]]; then
            cp -r "$source_dir" "$backup_dir/"
            log_info "Backed up: $dir"
        fi
    done

    log_success "Backup created at: $backup_dir"
}

# Restore from backup
cmd_restore() {
    local backup_dir="${1:-}"

    if [[ -z "$backup_dir" ]]; then
        log_error "Please specify backup directory"
        log_info "Usage: $SCRIPT_NAME restore <backup-directory>"
        exit 1
    fi

    if [[ ! -d "$backup_dir" ]]; then
        log_error "Backup directory not found: $backup_dir"
        exit 1
    fi

    log_info "Restoring from backup: $backup_dir"

    # Restore files
    find "$backup_dir" -type f -name ".*" | while read -r file; do
        local basename
        basename="$(basename "$file")"
        local target="$HOME/$basename"

        if [[ -f "$file" ]]; then
            cp "$file" "$target"
            log_info "Restored: $basename"
        fi
    done

    log_success "Restore complete"
}

# Show status
cmd_status() {
    log_info "Dotfiles Status Report"
    echo "======================="

    # Git status
    if check_git_repo 2>/dev/null; then
        cd "$DOTFILES_DIR"
        echo
        echo "Git Status:"
        git status --short --branch

        echo
        echo "Recent Commits:"
        git log --oneline -5
    fi

    # System info
    echo
    echo "System Info:"
    echo "OS: $(uname -s) $(uname -r)"
    echo "Shell: $SHELL"
    echo "Editor: ${EDITOR:-not set}"

    # Check important tools
    echo
    echo "Tool Status:"
    local tools=(git zsh tmux nvim)
    for tool in "${tools[@]}"; do
        if command -v "$tool" >/dev/null 2>&1; then
            printf "  ✓ %-8s %s\n" "$tool" "$(command -v "$tool")"
        else
            printf "  ✗ %-8s %s\n" "$tool" "not found"
        fi
    done
}

# Edit dotfiles
cmd_edit() {
    local editor="${EDITOR:-vim}"

    log_info "Opening dotfiles in $editor..."

    if [[ "$editor" == "nvim" || "$editor" == "vim" ]]; then
        # Open in editor with file explorer
        exec "$editor" "$DOTFILES_DIR"
    elif [[ "$editor" == "code" ]]; then
        # Open in VS Code
        exec code "$DOTFILES_DIR"
    else
        # Fallback to cd into directory
        log_info "Changed directory to: $DOTFILES_DIR"
        cd "$DOTFILES_DIR"
        exec "$SHELL"
    fi
}

# Run tests
cmd_test() {
    log_info "Running dotfiles tests..."

    local test_script="$DOTFILES_DIR/tests/test-install.sh"
    if [[ -f "$test_script" ]]; then
        exec "$test_script" "$@"
    else
        log_warn "Test script not found: $test_script"
        log_info "Running basic validation..."

        # Basic validation
        local errors=0

        # Check if essential files exist
        local essential_files=(
            "install/setup.sh"
            "config/zsh/zshrc"
            "config/git/gitconfig"
        )

        for file in "${essential_files[@]}"; do
            if [[ ! -f "$DOTFILES_DIR/$file" ]]; then
                log_error "Missing essential file: $file"
                ((errors++))
            fi
        done

        if [[ $errors -eq 0 ]]; then
            log_success "Basic validation passed"
        else
            log_error "Validation failed with $errors errors"
            exit 1
        fi
    fi
}

# Clean up
cmd_clean() {
    log_info "Cleaning up temporary files and old backups..."

    # Clean backup files older than 30 days
    find "$HOME" -maxdepth 1 -name ".dotfiles-backup-*" -type d -mtime +30 -exec rm -rf {} + 2>/dev/null || true

    # Clean temporary files
    rm -rf /tmp/dotfiles-* 2>/dev/null || true

    log_success "Cleanup complete"
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        install)
            cmd_install "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        sync)
            cmd_sync "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        edit)
            cmd_edit "$@"
            ;;
        test)
            cmd_test "$@"
            ;;
        clean)
            cmd_clean "$@"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"