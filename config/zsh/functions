# Essential utility functions for productivity

# =============================================================================
# File and Directory Operations
# =============================================================================

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Create project directory with git init
mkproject() {
    local name="$1"
    [[ -z "$name" ]] && { echo "Usage: mkproject <name>"; return 1; }
    mkdir "$name" && cd "$name" && git init
}

# Backup file with timestamp
backup() {
    cp "$1" "$1.bak.$(date +%Y%m%d_%H%M%S)"
}

# Extract various archive formats
extract() {
    if [[ -f "$1" ]]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"     ;;
            *.tar.gz)    tar xzf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar x "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xf "$1"      ;;
            *.tbz2)      tar xjf "$1"     ;;
            *.tgz)       tar xzf "$1"     ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# =============================================================================
# Git Functions
# =============================================================================

# Git clone and cd into directory
gclone() {
    git clone "$1" && cd "$(basename "$1" .git)"
}

# Git branch cleanup - delete merged branches
git-cleanup() {
    git branch --merged | grep -v "\*\|main\|master\|develop" | xargs -n 1 git branch -d
}

# Quick commit with auto-generated message
qc() {
    local message="$*"
    [[ -z "$message" ]] && message="update: $(git diff --name-only --cached | tr '\n' ' ')"
    [[ -z "$message" ]] && message="misc: updates"
    git add -u && git commit -m "$message"
}

# Add, commit, push workflow
acp() {
    git add -u
    git commit -m "${*:-update}"
    git push
}

# Git log with graph
gitlog() {
    git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)<%an>%Creset' --abbrev-commit "$@"
}

# gsl: Git shortlog with color, totals, and optional top-N limit
# Usage:
#   gsl                 -> show all contributors
#   gsl 10              -> show top 10 contributors
#   gsl 5 --since="1 year ago" -> show top 5 contributors in last year
gsl() {
    local limit=""
    if (( $# > 0 )); then
        limit="$1"
        shift
    fi

    # Color definitions
    local GREEN="\033[0;32m"
    local BOLDGREEN="\033[1;32m"
    local RESET="\033[0m"

    git shortlog -nes --group=author "$@" | awk -v limit="$limit" -v green="$GREEN" -v boldgreen="$BOLDGREEN" -v reset="$RESET" '
    BEGIN {rank=0}
    {
        rank++
        count=$1
        $1=""
        name=$0
        color = (rank <= 5) ? boldgreen : green
        if (limit == "" || rank <= limit) {
            printf "%s%5s%s %s\n", color, count, reset, name
        }
        total+=count
    }
    END {
        print "-----"
        printf "%sTotal:%s %d commits\n", boldgreen, reset, total
    }'
}

# =============================================================================
# Development Functions
# =============================================================================

# Start a simple HTTP server
http_serve() {
    local port="${1:-8000}"
    echo "Starting HTTP server on port $port..."
    python3 -m http.server "$port"
}

# Find and kill process by name
killp() {
    local process="$1"
    if [[ -z "$process" ]]; then
        echo "Usage: killp <process-name>"
        return 1
    fi

    local pids
    pids=$(pgrep -f "$process")

    if [[ -n "$pids" ]]; then
        echo "Found processes:"
        ps -p "$pids"
        echo -n "Kill these processes? (y/N): "
        read -r answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            kill "$pids"
            echo "Processes killed."
        fi
    else
        echo "No processes found matching '$process'"
    fi
}

# Get external IP address
myip() {
    curl -s https://ipinfo.io/ip
}

# Get local IP address
localip() {
    if command -v ip >/dev/null 2>&1; then
        ip route get 1.1.1.1 | grep -oP 'src \K\S+'
    elif command -v ifconfig >/dev/null 2>&1; then
        ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -1
    else
        echo "Unable to determine local IP"
    fi
}

# =============================================================================
# Docker Functions
# =============================================================================

# Docker cleanup
docker-cleanup() {
    echo "Cleaning up Docker..."
    docker system prune -af
    docker volume prune -f
}

# =============================================================================
# Utility Functions
# =============================================================================

# JSON pretty print
json() {
    if [[ -t 0 ]]; then
        # Read from argument
        echo "$1" | jq .
    else
        # Read from pipe
        jq .
    fi
}

# Enhanced status - git + system info
status() {
    echo "üìÅ $(pwd)"
    [[ -d .git ]] && echo "üîÄ $(git branch --show-current) | $(git status --porcelain | wc -l | tr -d ' ') changes"
    echo "üíæ $(df -h . | awk 'NR==2 {print $4}') free"
    echo "üîÑ $(uptime | cut -d, -f1)"
}

# Git workflow automation helper
workflowutil() {
    case "$1" in
        init) git init && git add . && git commit -m "initial commit" ;;
        push) git add -u && git commit -m "${2:-update}" && git push ;;
        pull) git pull && git submodule update ;;
        clean) git clean -fd && git reset --hard ;;
        *) echo "Usage: workflowutil {init|push [msg]|pull|clean}" ;;
    esac
}

# =============================================================================
# Dotfiles Management
# =============================================================================

# Edit dotfiles
dotfiles-edit() {
    cd "$DOTFILES" && "$EDITOR" .
}

# Reload zsh configuration
reload() {
    source "$HOME/.zshrc"
    echo "Zsh configuration reloaded!"
}
