# Shell Functions - Organized by Category
# All functions preserved, reorganized for clarity

# =============================================================================
# FILE & DIRECTORY OPERATIONS
# =============================================================================

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Backup file with timestamp
backup() {
    cp "$1" "$1.bak.$(date +%Y%m%d_%H%M%S)"
}

# Extract various archive formats
extract() {
    if [[ -f "$1" ]]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"     ;;
            *.tar.gz)    tar xzf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar x "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xf "$1"      ;;
            *.tbz2)      tar xjf "$1"     ;;
            *.tgz)       tar xzf "$1"     ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Find files by name
ff() {
    find . -type f -name "*$1*" 2>/dev/null
}

# Find directories by name
fdir() {
    find . -type d -name "*$1*" 2>/dev/null
}

# Find the largest files in current directory
unalias findbig 2>/dev/null
findbig() {
    /usr/bin/find . -type f -exec ls -s {} \; 2>/dev/null | sort -n -r | head -5
}

# =============================================================================
# GIT OPERATIONS
# =============================================================================

# Git clone and cd into directory
gclone() {
    git clone "$1" && cd "$(basename "$1" .git)"
}

# Git branch cleanup - delete merged branches
git-cleanup() {
    git branch --merged | grep -v "\*\|main\|master\|develop" | xargs -n 1 git branch -d
}

# Git log with graph
gitlog() {
    git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)<%an>%Creset' --abbrev-commit "$@"
}

# Git shortlog with color, totals, and optional top-N limit
# Usage:
#   gsl                 -> show all contributors
#   gsl 10              -> show top 10 contributors
#   gsl 5 --since="1 year ago" -> show top 5 contributors in last year
gsl() {
    local limit=""
    if (( $# > 0 )); then
        limit="$1"
        shift
    fi

    # Color definitions
    local GREEN="\033[0;32m"
    local BOLDGREEN="\033[1;32m"
    local RESET="\033[0m"

    git shortlog -nes --group=author "$@" | awk -v limit="$limit" -v green="$GREEN" -v boldgreen="$BOLDGREEN" -v reset="$RESET" '
    BEGIN {rank=0}
    {
        rank++
        count=$1
        $1=""
        name=$0
        color = (rank <= 5) ? boldgreen : green
        if (limit == "" || rank <= limit) {
            printf "%s%5s%s %s\n", color, count, reset, name
        }
        total+=count
    }
    END {
        print "-----"
        printf "%sTotal:%s %d commits\n", boldgreen, reset, total
    }'
}

# Quick commit with auto-generated message
qc() {
    local message="$*"
    [[ -z "$message" ]] && message="update: $(git diff --name-only --cached | tr '\n' ' ')"
    [[ -z "$message" ]] && message="misc: updates"
    git add -u && git commit -m "$message"
}

# Add, commit, push workflow
acp() {
    git add -u
    git commit -m "${*:-update}"
    git push
}

# =============================================================================
# DEVELOPMENT & PROCESSES
# =============================================================================

# Start a simple HTTP server
http_serve() {
    local port="${1:-8000}"
    echo "Starting HTTP server on port $port..."
    python3 -m http.server "$port"
}

# Find and kill process by name
killp() {
    local process="$1"
    if [[ -z "$process" ]]; then
        echo "Usage: killp <process-name>"
        return 1
    fi

    local pids
    pids=$(pgrep -f "$process")

    if [[ -n "$pids" ]]; then
        echo "Found processes:"
        ps -p "$pids"
        echo -n "Kill these processes? (y/N): "
        read -r answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            kill "$pids"
            echo "Processes killed."
        fi
    else
        echo "No processes found matching '$process'"
    fi
}

# =============================================================================
# SYSTEM INFORMATION
# =============================================================================

# System information
sysinfo() {
    echo "System Information:"
    echo "=================="
    echo "Hostname: $(hostname)"
    echo "OS: $(uname -s) $(uname -r)"
    echo "Architecture: $(uname -m)"
    echo "Uptime: $(uptime)"
    echo "Shell: $SHELL"
    echo "Terminal: $TERM"
    if command -v lsb_release >/dev/null 2>&1; then
        echo "Distribution: $(lsb_release -d | cut -f2-)"
    fi
}

# Disk usage in current directory
duh() {
    du -h --max-depth=1 2>/dev/null | sort -hr
}

# Memory usage
meminfo() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        vm_stat | perl -ne '/page size of (\d+)/ and $size=$1; /Pages\s+([^:]+):\s+(\d+)/ and printf("%-16s % 16.2f MB\\n", "$1:", $2 * $size / 1048576);'
    else
        free -h
    fi
}

# Get external IP address
myip() {
    curl -s https://ipinfo.io/ip
}

# Get local IP address
localip() {
    if command -v ip >/dev/null 2>&1; then
        ip route get 1.1.1.1 | grep -oP 'src \K\S+'
    elif command -v ifconfig >/dev/null 2>&1; then
        ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -1
    else
        echo "Unable to determine local IP"
    fi
}

# =============================================================================
# DOCKER OPERATIONS
# =============================================================================

# Docker cleanup
docker-cleanup() {
    echo "Cleaning up Docker..."
    docker system prune -af
    docker volume prune -f
}

# Docker shell into container
dsh() {
    local container="$1"
    if [[ -z "$container" ]]; then
        echo "Usage: dsh <container-name-or-id>"
        return 1
    fi
    docker exec -it "$container" /bin/bash
}

# =============================================================================
# KUBERNETES OPERATIONS
# =============================================================================

# Kubernetes context switching
kctx() {
    if [[ -z "$1" ]]; then
        kubectl config get-contexts
    else
        kubectl config use-context "$1"
    fi
}

# Kubernetes namespace switching
kns() {
    if [[ -z "$1" ]]; then
        kubectl get namespaces
    else
        kubectl config set-context --current --namespace="$1"
    fi
}

# =============================================================================
# TMUX SESSION MANAGEMENT
# =============================================================================

# Tmux session manager
tm() {
    local session="$1"
    if [[ -z "$session" ]]; then
        tmux list-sessions
    elif tmux has-session -t "$session" 2>/dev/null; then
        tmux attach-session -t "$session"
    else
        tmux new-session -s "$session"
    fi
}

# =============================================================================
# TEXT & DATA PROCESSING
# =============================================================================

# Convert to lowercase
lower() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

# Convert to uppercase
upper() {
    echo "$1" | tr '[:lower:]' '[:upper:]'
}

# Generate random password
genpass() {
    local length="${1:-16}"
    LC_ALL=C tr -dc 'A-Za-z0-9!@#$%^&*()_+=' < /dev/urandom | head -c "$length"
    echo
}

# JSON pretty print
json() {
    if [[ -t 0 ]]; then
        # Read from argument
        echo "$1" | jq .
    else
        # Read from pipe
        jq .
    fi
}

# URL encode
urlencode() {
    python3 -c "import urllib.parse; print(urllib.parse.quote('$1'))"
}

# URL decode
urldecode() {
    python3 -c "import urllib.parse; print(urllib.parse.unquote('$1'))"
}

# =============================================================================
# VISUALIZATION & UTILITIES
# =============================================================================

# Gource quick alias (interactive)
alias gourceq='gource --seconds-per-day 0.05 --max-files 300 --file-idle-time 10 --highlight-all-users --auto-skip-seconds 1 --background-colour 000000 --title "$(basename $(pwd))" --key --hide-dirnames --camera-mode overview'

# Gource viewer function (interactive, customizable)
gourcev() {
    # Check dependencies
    if ! command -v gource >/dev/null 2>&1; then
        echo "Error: gource is not installed" >&2
        return 1
    fi
    if ! command -v ffplay >/dev/null 2>&1; then
        echo "Error: ffplay (ffmpeg) is not installed" >&2
        return 1
    fi

    # Usage: gourcev [path] [resolution] [days-per-second]
    # Example: gourcev /path/to/repo 1280x720 0.05
    local repo="${1:-.}"
    local res="${2:-1280x720}"
    local spd="${3:-0.05}"            # seconds-per-day
    local maxfiles=400
    local idle=12
    local title="$(basename "$(cd "$repo" && pwd)")"
    cd "$repo" || return 1

    gource \
        --multi-sampling \
        --seconds-per-day "$spd" \
        --max-files "$maxfiles" \
        --file-idle-time "$idle" \
        --highlight-all-users \
        --auto-skip-seconds 1 \
        --background-colour 000000 \
        --title "$title" \
        --key \
        --camera-mode overview \
        --hide-dirnames \
        --output-ppm-stream - \
        -"$res" \
        | ffplay -loglevel warning -framerate 60 -i -
}

# Gource -> MP4/WebM renderer
# Usage: gourcevid /path/to/repo out.mp4 1920x1080 60
gourcevid() {
    # Check dependencies
    if ! command -v gource >/dev/null 2>&1; then
        echo "Error: gource is not installed" >&2
        return 1
    fi
    if ! command -v ffmpeg >/dev/null 2>&1; then
        echo "Error: ffmpeg is not installed" >&2
        return 1
    fi

    local repo="${1:-.}"
    local out="${2:-gource.mp4}"
    local res="${3:-1920x1080}"
    local fr="${4:-60}"               # output frame rate
    local spd="${5:-0.05}"            # seconds-per-day
    local bitrate="${6:-12000k}"

    cd "$repo" || return 1

    # Gource generates ppm frames to stdout; pipe to ffmpeg to encode
    gource \
        --seconds-per-day "$spd" \
        --max-files 500 \
        --file-idle-time 10 \
        --highlight-all-users \
        --auto-skip-seconds 1 \
        --background-colour 000000 \
        --title "$(basename "$(cd "$repo" && pwd)")" \
        --key \
        --camera-mode overview \
        -"$res" \
        --output-ppm-stream - \
    | ffmpeg -y -r "$fr" -f image2pipe -vcodec ppm -i - \
        -vcodec libx264 -preset slow -pix_fmt yuv420p -crf 18 -b:v "$bitrate" "$out"
}

# Weather report
weather() {
    local location="${1:-}"
    curl -s "https://wttr.in/$location?format=3"
}

# QR code generator
qr() {
    if [[ -z "$1" ]]; then
        echo "Usage: qr <text>"
        return 1
    fi
    curl -s "https://qr-server.com/api/v1/create-qr-code/?size=200x200&data=$1"
}

# Calculator
calc() {
    python3 -c "print($*)"
}

# Benchmark command execution time
timecmd() {
    time ( "$@" )
}

# =============================================================================
# DOTFILES & WORKFLOW MANAGEMENT
# =============================================================================

# Edit dotfiles
dotfiles-edit() {
    cd "$DOTFILES" && "$EDITOR" .
}

# Reload zsh configuration
reload() {
    source "$HOME/.zshrc"
    rehash
    echo "Zsh configuration reloaded!"
}

# Enhanced status - git + system info
status() {
    echo "üìÅ $(pwd)"
    [[ -d .git ]] && echo "üîÄ $(git branch --show-current) | $(git status --porcelain | wc -l | tr -d ' ') changes"
    echo "üíæ $(df -h . | awk 'NR==2 {print $4}') free"
    echo "üîÑ $(uptime | cut -d, -f1)"
}

# Git workflow automation helper
workflowutil() {
    case "$1" in
        init) git init && git add . && git commit -m "initial commit" ;;
        push) git add -u && git commit -m "${2:-update}" && git push ;;
        pull) git pull && git submodule update ;;
        clean) git clean -fd && git reset --hard ;;
        *) echo "Usage: workflowutil {init|push [msg]|pull|clean}" ;;
    esac
}

# Create project directory with git init
mkproject() {
    local name="$1"
    [[ -z "$name" ]] && { echo "Usage: mkproject <name>"; return 1; }
    mkdir "$name" && cd "$name" && git init
}
