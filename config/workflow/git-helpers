#!/usr/bin/env bash
# Simple Git Helpers
# Essential git shortcuts for daily workflows

set -euo pipefail

# Source shared utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/utils"

# Check if we're in a git repository
ensure_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a git repository"
        exit 1
    fi
}

# Generate smart commit message suggestions
suggest_commit_message() {
    local staged_files suggestions=()

    # Get staged changes
    staged_files=$(git diff --cached --name-only)
    if [[ -z $staged_files ]]; then
        echo "No staged changes found"
        return 1
    fi

    # Analyze changes for smart suggestions
    if echo "$staged_files" | grep -q "README\|\.md$"; then
        suggestions+=("üìö Update documentation")
    fi

    if echo "$staged_files" | grep -q "test\|spec\|\.test\."; then
        suggestions+=("‚úÖ Add tests" "üîß Fix tests")
    fi

    if echo "$staged_files" | grep -q "package\.json\|Cargo\.toml\|requirements\.txt\|go\.mod"; then
        suggestions+=("‚¨ÜÔ∏è Update dependencies" "üì¶ Add dependency")
    fi

    if echo "$staged_files" | grep -q "config\|\.env\|\.yml$\|\.yaml$"; then
        suggestions+=("üîß Update configuration")
    fi

    if echo "$staged_files" | grep -q "\.sh$\|Makefile\|bin/"; then
        suggestions+=("üîß Update build scripts")
    fi

    # Generic suggestions based on git status
    if git diff --cached --name-only | wc -l | grep -q "^1$"; then
        local file_name
        file_name=$(git diff --cached --name-only)
        suggestions+=("Update ${file_name##*/}")
    fi

    # Common conventional commit types
    suggestions+=(
        "feat: add new feature"
        "fix: resolve bug"
        "refactor: improve code structure"
        "style: format code"
        "chore: maintenance tasks"
    )

    # Display suggestions
    echo "Suggested commit messages:"
    for i in "${!suggestions[@]}"; do
        printf "%2d. %s\n" $((i + 1)) "${suggestions[$i]}"
    done

    echo "Or type custom message:"
}

# Quick add, commit, and push
quick_save() {
    local dry_run="${1:-false}"
    ensure_git_repo

    if [[ $dry_run == "true" ]]; then
        log_info "[DRY RUN] Would add all changes: git add ."
        log_info "[DRY RUN] Would show commit message suggestions"
        log_info "[DRY RUN] Would commit and push to current branch"
        return 0
    fi

    # Add all changes
    git add .
    log_success "Staged all changes"

    # Show suggestions
    suggest_commit_message

    # Get commit message
    echo
    read -p "Commit message (or number): " -r input
    if [[ -z $input ]]; then
        log_error "Commit message required"
        return 1
    fi

    # Parse input - number or custom message
    local message
    if [[ $input =~ ^[0-9]+$ ]]; then
        # User selected a number - get fresh suggestions
        local temp_suggestions
        if ! mapfile -t temp_suggestions < <(suggest_commit_message | grep "^[[:space:]]*[0-9]" | sed 's/^[[:space:]]*[0-9]*\. //'); then
            log_error "Failed to generate commit message suggestions"
            return 1
        fi

        if [[ ${#temp_suggestions[@]} -eq 0 ]]; then
            log_error "No suggestions available"
            return 1
        fi

        local index=$((input - 1))
        if [[ $index -ge 0 && $index -lt ${#temp_suggestions[@]} ]]; then
            message="${temp_suggestions[$index]}"
        else
            log_error "Invalid selection. Please choose 1-${#temp_suggestions[@]}"
            return 1
        fi
    else
        message="$input"
    fi

    # Commit
    git commit -m "$message"
    log_success "Created commit: $message"

    # Push (with upstream if needed)
    local current_branch
    current_branch=$(git branch --show-current)

    if git push 2>/dev/null; then
        log_success "Pushed to $current_branch"
    elif git push -u origin "$current_branch" 2>/dev/null; then
        log_success "Pushed and set upstream for $current_branch"
    else
        log_error "Push failed - check remote configuration"
    fi
}

# Quick pull with rebase
quick_pull() {
    local dry_run="${1:-false}"
    ensure_git_repo

    if [[ $dry_run == "true" ]]; then
        log_info "[DRY RUN] Would pull with rebase: git pull --rebase"
        return 0
    fi

    if git pull --rebase; then
        log_success "Successfully pulled with rebase"
    else
        log_error "Pull failed - resolve conflicts manually"
        echo "  git status        # Check conflicts"
        echo "  git add <files>   # After resolving"
        echo "  git rebase --continue"
    fi
}

# Show simple status
quick_status() {
    ensure_git_repo

    echo "Git Status"
    echo "=========="

    local current_branch
    current_branch=$(git branch --show-current)
    echo "Branch: $current_branch"

    # Check if there are changes
    if git diff-index --quiet HEAD --; then
        echo "Status: Clean working directory"
    else
        echo "Status: Working directory has changes"
        git status --short
    fi

    # Check sync status if upstream exists
    if git config "branch.$current_branch.remote" >/dev/null 2>&1; then
        local ahead behind
        ahead=$(git rev-list --count "@{upstream}..HEAD" 2>/dev/null || echo "0")
        behind=$(git rev-list --count "HEAD..@{upstream}" 2>/dev/null || echo "0")

        if [[ $ahead -gt 0 || $behind -gt 0 ]]; then
            echo "Sync: $ahead ahead, $behind behind"
        else
            echo "Sync: Up to date"
        fi
    fi
}

# Branch management utilities
branch_new() {
    local branch_name="$1"
    if [[ -z $branch_name ]]; then
        log_error "Branch name required"
        return 1
    fi

    ensure_git_repo

    git checkout -b "$branch_name"
    log_success "Created and switched to branch: $branch_name"
}

branch_switch() {
    local branch_name="$1"
    if [[ -z $branch_name ]]; then
        # Show available branches
        echo "Available branches:"
        git branch -a | sed 's/^[* ] //'
        return 0
    fi

    ensure_git_repo

    if git checkout "$branch_name"; then
        log_success "Switched to branch: $branch_name"
    else
        log_error "Failed to switch to branch: $branch_name"
    fi
}

branch_clean() {
    ensure_git_repo

    echo "Cleaning merged branches..."
    local merged_branches
    merged_branches=$(git branch --merged | grep -v "\*\|main\|master" | xargs -n 1)

    if [[ -z $merged_branches ]]; then
        log_info "No merged branches to clean"
        return 0
    fi

    echo "Merged branches to delete:"
    echo "$merged_branches"

    read -p "Delete these branches? (y/N): " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo "$merged_branches" | xargs -n 1 git branch -d
        log_success "Deleted merged branches"
    fi
}

# Usage information
usage() {
    cat <<EOF
Simple Git Helpers

USAGE:
    git-helpers [COMMAND] [OPTIONS]

COMMANDS:
    save        Quick add, commit, and push workflow with smart suggestions
    pull        Pull with rebase and conflict guidance
    status      Show simple repository status
    new         Create and switch to new branch
    switch      Switch to existing branch (no args shows all branches)
    clean       Delete merged branches interactively
    help        Show this help message

OPTIONS:
    -n, --dry-run   Show what would be done without executing

EXAMPLES:
    git-helpers save         # Add all, commit with smart suggestions, push
    git-helpers save -n      # Show what save would do (dry run)
    git-helpers pull         # Pull with rebase
    git-helpers status       # Show branch and sync status
    git-helpers new feature  # Create and switch to 'feature' branch
    git-helpers switch main  # Switch to main branch
    git-helpers clean        # Clean up merged branches

SHORTCUTS:
    These commands provide simple workflows for common git operations.
    For complex operations, use git commands directly.
EOF
}

# Main function
main() {
    local command="${1:-status}"
    local dry_run=false

    # Check for dry run flag
    if [[ ${2:-} == "-n" || ${2:-} == "--dry-run" ]]; then
        dry_run=true
    fi

    case "$command" in
        save)
            quick_save "$dry_run"
            ;;
        pull)
            quick_pull "$dry_run"
            ;;
        status | st)
            quick_status
            ;;
        new)
            branch_new "${2:-}"
            ;;
        switch | sw)
            branch_switch "${2:-}"
            ;;
        clean)
            branch_clean
            ;;
        help | --help | -h)
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            usage
            exit 1
            ;;
    esac
}

# Only run main if script is executed directly
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
    main "$@"
fi
